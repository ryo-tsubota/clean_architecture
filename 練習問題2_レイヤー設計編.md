# 練習問題2: レイヤー設計編

## 問題2-1: リポジトリパターンの設計

以下の要件に基づいて、ユーザー管理システムのリポジトリインターフェースを設計してください。

**要件:**
- ユーザーの作成、取得、更新、削除ができる
- メールアドレスでユーザーを検索できる
- アクティブなユーザーのみを取得できる
- ページネーション機能がある

**課題:**
1. `IUserRepository`インターフェースを定義してください
2. エンティティ層の`User`クラスを設計してください
3. インメモリ実装`InMemoryUserRepository`を作成してください

## 問題2-2: DTOとエンティティの変換

以下のエンティティとDTOが与えられています。変換ロジックを実装してください。

**エンティティ:**
```python
@dataclass
class Product:
    id: str
    name: str
    price: int  # 円単位
    category_id: str
    created_at: datetime
    is_active: bool = True
```

**DTO:**
```python
class ProductCreateDTO(BaseModel):
    name: str
    price: int
    category_id: str

class ProductResponseDTO(BaseModel):
    id: str
    name: str
    price: int
    category_name: str  # カテゴリIDではなく名前
    created_at: str     # ISO形式の文字列
```

**課題:**
1. `ProductCreateDTO`から`Product`エンティティへの変換メソッドを作成
2. `Product`エンティティから`ProductResponseDTO`への変換メソッドを作成
3. カテゴリ名の取得はどのレイヤーで行うべきか説明してください

## 問題2-3: ユースケースの設計

ECサイトの注文処理機能を設計してください。

**ビジネスルール:**
- 在庫が足りない商品は注文できない
- 注文金額が10,000円以上の場合は送料無料
- 注文完了時にメール通知を送信する
- 注文履歴を記録する

**課題:**
1. 必要なリポジトリインターフェースを定義してください
2. `OrderUseCase`クラスを設計してください
3. 必要なDTOを定義してください
4. メール送信はどのレイヤーで処理すべきか説明してください

## 問題2-4: アダプターパターンの実装

外部APIから商品情報を取得するアダプターを実装してください。

**外部API仕様:**
```json
{
  "product_id": "ext_12345",
  "product_name": "外部商品名",
  "cost": 1500,
  "category": {
    "id": "cat_01",
    "name": "カテゴリA"
  },
  "availability": true
}
```

**内部エンティティ:**
```python
@dataclass
class Product:
    id: str
    name: str
    price: int
    category_id: str
    is_available: bool
```

**課題:**
1. 外部APIのレスポンスモデルを定義してください
2. `ExternalProductAdapter`クラスを実装してください
3. このアダプターはどのレイヤーに配置すべきか説明してください

## 問題2-5: コントローラーの責務

以下のコントローラーコードを分析し、問題点を指摘してください。

```python
@router.post("/users")
async def create_user(request: Request):
    # リクエストボディの取得
    body = await request.json()
    
    # バリデーション
    if not body.get("email"):
        return JSONResponse(
            status_code=400, 
            content={"error": "メールアドレスは必須です"}
        )
    
    if not re.match(r"[^@]+@[^@]+\.[^@]+", body["email"]):
        return JSONResponse(
            status_code=400,
            content={"error": "無効なメールアドレスです"}
        )
    
    # ビジネスロジック
    user_id = str(uuid.uuid4())
    created_at = datetime.now()
    
    # データベース操作
    conn = get_database_connection()
    cursor = conn.cursor()
    cursor.execute(
        "INSERT INTO users (id, email, created_at) VALUES (?, ?, ?)",
        (user_id, body["email"], created_at)
    )
    conn.commit()
    
    # メール送信
    send_welcome_email(body["email"])
    
    return JSONResponse(
        status_code=201,
        content={
            "id": user_id,
            "email": body["email"],
            "created_at": created_at.isoformat()
        }
    )
```

**課題:**
1. このコードの問題点を5つ以上挙げてください
2. クリーンアーキテクチャに従って改善案を提示してください

## 問題2-6: レイヤー間の通信

以下のシナリオで、各レイヤー間の適切な通信方法を説明してください。

**シナリオ:**
ユーザーがブログ記事を作成する際に：
1. 認証・認可チェックを行う
2. 記事の内容をバリデーションする
3. 記事を保存する
4. 検索インデックスを更新する
5. 通知を送信する

**課題:**
1. 各処理はどのレイヤーで実行すべきか説明してください
2. レイヤー間でのデータの受け渡し方法を設計してください
3. 外部サービス（検索エンジン、通知サービス）との連携はどう実装しますか？

---

## 解答例

### 問題2-1の解答例

```python
# IUserRepository
class IUserRepository(ABC):
    @abstractmethod
    def save(self, user: User) -> User:
        pass
    
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        pass
    
    @abstractmethod
    def find_by_email(self, email: str) -> Optional[User]:
        pass
    
    @abstractmethod
    def find_active_users(self, page: int, size: int) -> List[User]:
        pass
    
    @abstractmethod
    def delete(self, user_id: str) -> bool:
        pass

# User Entity
@dataclass
class User:
    email: str
    name: str
    is_active: bool = True
    id: str = field(default_factory=lambda: str(uuid.uuid4()))
    created_at: datetime = field(default_factory=datetime.now)
```

### 問題2-5の解答例

**問題点:**
1. DTOを使用していない（直接JSONを処理）
2. バリデーションロジックがコントローラーに混在
3. ビジネスロジック（ID生成）がコントローラーにある
4. データベースアクセスが直接実行されている
5. メール送信などの外部サービス呼び出しが混在
6. エラーハンドリングが不十分
7. レスポンス生成ロジックが複雑

**改善案:**
- DTOを定義してバリデーションを分離
- ユースケース層を作成してビジネスロジックを移動
- リポジトリパターンでデータアクセスを抽象化
- 外部サービスのインターフェースを定義