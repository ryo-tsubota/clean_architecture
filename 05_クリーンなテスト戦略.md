# 第5章: クリーンなテスト戦略

クリーンアーキテクチャを採用する最大の動機の一つが「テスト容易性の向上」です。ビジネスロジックがフレームワークやデータベースといった外部の関心事から分離されているため、各コンポーネントを独立して、かつ効率的にテストすることが可能になります。

この章では、`pytest` を用いて、各レイヤーに応じたテスト戦略と具体的な実装方法を学びます。

## 5-1. なぜクリーンアーキテクチャはテストしやすいのか

従来の密結合なアーキテクチャ（例えば、フレームワークの作法に則り、コントローラーにビジネスロジックとDBアクセスが混在している状態）では、一つの機能をテストするために、Webサーバーの起動やデータベースへの接続が必須になることがよくありました。このようなテストは「遅い」「不安定」「セットアップが複雑」という問題を抱えがちです。

クリーンアーキテクチャでは、この問題が以下のように解決されます。

1.  **ビジネスロジックの純粋性**: ユースケース層は、特定のDB実装やWebフレームワークを知りません。そのため、これらの低速で不安定な要素を「モック」や「スタブ」と呼ばれる偽のオブジェクトに差し替えることで、ビジネスロジックそのものを高速にテストできます。

2.  **依存性の注入(DI)の活用**: DIを用いることで、テスト時に本番用のリポジトリ実装（例: `SqlAlchemyTodoItemRepository`）を、テスト用のインメモリ実装（例: `InMemoryTodoItemRepository`）に簡単に入れ替えることができます。これにより、データベース接続なしにユースケースの振る舞いを検証できます。

3.  **責務の明確化**: 各レイヤーの責務が明確であるため、「何をテストすべきか」が分かりやすくなります。ユースケースはビジネスルールを、リポジトリはデータ永続化を、コントローラーはHTTPの入出力を、それぞれテストの対象とします。

## 5-2. 各レイヤーのテスト手法

テストは、その目的と範囲に応じていくつかの種類に分類されます。クリーンアーキテクチャの各レイヤーには、それぞれ適したテスト手法があります。

*   **エンティティ (Entity) のユニットテスト**
    *   **目的**: エンティティ内のビジネスロジック（メソッド）が正しく動作することを確認する。
    *   **方法**: エンティティをインスタンス化し、そのメソッドを直接呼び出して結果を検証します。外部依存がないため、最もシンプルで高速なテストです。

*   **ユースケース (Use Case) のユニットテスト**
    *   **目的**: アプリケーションのビジネスロジックが、期待通りにエンティティやリポジトリ（のインターフェース）を操作することを確認する。
    *   **方法**: テスト用のリポジトリ実装（インメモリ版など）をユースケースに注入（DI）して実行します。データベースやネットワークアクセスが発生しないため、非常に高速です。

*   **リポジトリ (Repository) のインテグレーションテスト**
    *   **目的**: リポジトリの実装が、実際のデータベースと正しく対話できることを確認する。
    *   **方法**: テスト用のデータベース（例: インメモリSQLiteや、Dockerで起動した本番と同じDB）に接続し、CRUD（作成、読み取り、更新、削除）操作が正しく行えるかを検証します。外部I/Oを伴うため、ユニットテストよりは低速です。

*   **API (Controller) のE2Eテスト (エンドツーエンドテスト)**
    *   **目的**: 実際のHTTPリクエストを通じて、APIエンドポイントが全体として正しく機能することを確認する。
    *   **方法**: FastAPIの `TestClient` のようなツールを使い、アプリケーションにHTTPリクエストを送信し、返ってきたレスポンスのステータスコードやJSONボディを検証します。すべてのレイヤーを通過する統合的なテストです。

## 5-3. `pytest` を使ったテストの実装例

それでは、第4章で作成したToDoリストAPIのテストを書いてみましょう。

まず、テスト用のライブラリをインストールします。
```bash
pip install pytest
```

#### 1. ユースケースのユニットテスト

ユースケースのテストでは、高速なインメモリリポジトリを使ってロジックを検証します。

`tests/test_use_cases.py` (新規作成)
```python
import pytest
from src.application.use_cases import TodoUseCases
from src.application.dtos import CreateTodoDTO
from src.infrastructure.database.repositories import InMemoryTodoItemRepository

@pytest.fixture
def todo_use_cases() -> TodoUseCases:
    """テスト用のユースケースインスタンスを返すfixture"""
    repo = InMemoryTodoItemRepository()
    return TodoUseCases(repo=repo)

def test_create_todo(todo_use_cases: TodoUseCases):
    """ToDo作成ユースケースのテスト"""
    # Arrange
    dto = CreateTodoDTO(title="Test Todo")

    # Act
    result = todo_use_cases.create_todo(dto)

    # Assert
    assert result.title == "Test Todo"
    assert not result.completed
    assert result.id is not None

    # 状態の確認
    all_todos = todo_use_cases.get_all_todos()
    assert len(all_todos) == 1
    assert all_todos[0].title == "Test Todo"

def test_complete_todo(todo_use_cases: TodoUseCases):
    """ToDo完了ユースケースのテスト"""
    # Arrange: 最初にタスクを作成
    created = todo_use_cases.create_todo(CreateTodoDTO(title="Incomplete Todo"))
    assert not created.completed

    # Act: タスクを完了させる
    completed_todo = todo_use_cases.complete_todo(created.id)

    # Assert
    assert completed_todo.id == created.id
    assert completed_todo.completed

    # 例外ケースのテスト
    with pytest.raises(ValueError, match="Todo not found"):
        todo_use_cases.complete_todo("non_existent_id")
```

このテストはデータベースを一切使用しないため、一瞬で完了します。

#### 2. APIのE2Eテスト

FastAPIの `TestClient` を使って、APIエンドポイントをテストします。DIコンテナをテストモードで設定し、インメモリリポジトリを使用するようにオーバーライドします。

`tests/conftest.py` (新規作成)
```python
import pytest
from fastapi.testclient import TestClient

from src.main import create_app
from src.container import Container
from src.infrastructure.database.repositories import InMemoryTodoItemRepository

@pytest.fixture(scope="session")
def test_app():
    """テスト用のFastAPIアプリケーションインスタンスを作成"""
    container = Container()
    # DIコンテナのリポジトリ実装をインメモリ版に上書き
    container.todo_repository.override(InMemoryTodoItemRepository())
    
    app = create_app()
    app.container = container
    return app

@pytest.fixture
def client(test_app):
    """テスト用のHTTPクライアント"""
    return TestClient(test_app)
```

`tests/test_api.py` (新規作成)
```python
from fastapi.testclient import TestClient

def test_create_and_get_todos_e2e(client: TestClient):
    """ToDoの作成と取得を行うE2Eテスト"""
    # 1. 最初はToDoが0件であることを確認
    response = client.get("/todos")
    assert response.status_code == 200
    assert response.json() == []

    # 2. 新しいToDoを作成する
    response = client.post("/todos", json={"title": "API Test Todo"})
    assert response.status_code == 200
    created_todo = response.json()
    assert created_todo["title"] == "API Test Todo"
    assert not created_todo["completed"]
    todo_id = created_todo["id"]

    # 3. ToDoが1件存在することを確認
    response = client.get("/todos")
    assert response.status_code == 200
    todos = response.json()
    assert len(todos) == 1
    assert todos[0]["id"] == todo_id

    # 4. ToDoを完了させる
    response = client.post(f"/todos/{todo_id}/complete")
    assert response.status_code == 200
    completed_todo = response.json()
    assert completed_todo["completed"]
```

このように、DIコンテナをうまく使うことで、E2Eテストですら実際のデータベースに依存させずに実行できます。これにより、CI/CDパイプラインなどでの自動テストが非常に容易になります。
