# 練習問題5: テスト戦略編

## 問題5-1: テストピラミッドの設計

クリーンアーキテクチャのToDoアプリケーションに対して、適切なテスト戦略を設計してください。

### 課題

**1. 各レイヤーのテスト責務を明確にしてください**
- Entity層: 何をテストすべきか？
- Use Case層: 何をテストすべきか？
- Interface Adapter層: 何をテストすべきか？
- Framework層: 何をテストすべきか？

**2. テストの分類と実装方針**
各テストタイプの実装方針を説明してください：
- Unit Tests
- Integration Tests  
- End-to-End Tests

**3. テストピラミッドの比率**
各テストタイプの適切な比率と理由を説明してください。

## 問題5-2: Entity層のユニットテスト

以下のエンティティに対して包括的なユニットテストを作成してください。

```python
@dataclass
class Order:
    id: str
    customer_id: str
    items: List['OrderItem']
    status: OrderStatus = OrderStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    total_amount: int = 0
    
    def add_item(self, product_id: str, quantity: int, unit_price: int) -> None:
        if quantity <= 0:
            raise ValueError("数量は1以上である必要があります")
        
        # 既存商品の場合は数量を加算
        for item in self.items:
            if item.product_id == product_id:
                item.quantity += quantity
                self._calculate_total()
                return
        
        # 新規商品の追加
        item = OrderItem(
            id=str(uuid.uuid4()),
            product_id=product_id,
            quantity=quantity,
            unit_price=unit_price
        )
        self.items.append(item)
        self._calculate_total()
    
    def remove_item(self, product_id: str) -> None:
        self.items = [item for item in self.items if item.product_id != product_id]
        self._calculate_total()
    
    def confirm(self) -> None:
        if not self.items:
            raise ValueError("商品が選択されていません")
        if self.status != OrderStatus.PENDING:
            raise ValueError("注文済みの商品は確定できません")
        
        self.status = OrderStatus.CONFIRMED
    
    def _calculate_total(self) -> None:
        self.total_amount = sum(item.quantity * item.unit_price for item in self.items)

@dataclass
class OrderItem:
    id: str
    product_id: str
    quantity: int
    unit_price: int

class OrderStatus(Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
```

### 課題

**1. 正常系テストケース**
- 商品追加の正常系
- 商品削除の正常系
- 注文確定の正常系

**2. 異常系テストケース**
- 不正な数量での商品追加
- 空の注文での確定
- 確定済み注文の再確定

**3. エッジケース**
- 同一商品の複数回追加
- 存在しない商品の削除
- 金額計算の正確性

## 問題5-3: Use Case層のテスト（モック使用）

以下のユースケースクラスに対してテストを作成してください。

```python
class CreateOrderUseCase:
    def __init__(
        self,
        order_repo: IOrderRepository,
        product_repo: IProductRepository,
        customer_repo: ICustomerRepository,
        inventory_service: IInventoryService,
        email_service: IEmailService
    ):
        self.order_repo = order_repo
        self.product_repo = product_repo
        self.customer_repo = customer_repo
        self.inventory_service = inventory_service
        self.email_service = email_service
    
    def execute(self, dto: CreateOrderDTO) -> OrderDTO:
        # 顧客存在チェック
        customer = self.customer_repo.find_by_id(dto.customer_id)
        if not customer:
            raise CustomerNotFoundException(dto.customer_id)
        
        # 注文作成
        order = Order(
            id=str(uuid.uuid4()),
            customer_id=dto.customer_id,
            items=[]
        )
        
        # 商品追加と在庫チェック
        for item_dto in dto.items:
            product = self.product_repo.find_by_id(item_dto.product_id)
            if not product:
                raise ProductNotFoundException(item_dto.product_id)
            
            # 在庫チェック
            if not self.inventory_service.check_availability(
                item_dto.product_id, item_dto.quantity
            ):
                raise InsufficientStockException(item_dto.product_id)
            
            order.add_item(
                item_dto.product_id,
                item_dto.quantity,
                product.price
            )
        
        # 在庫引当
        for item in order.items:
            self.inventory_service.reserve_stock(item.product_id, item.quantity)
        
        # 注文確定
        order.confirm()
        
        # 保存
        saved_order = self.order_repo.save(order)
        
        # 確認メール送信
        self.email_service.send_order_confirmation(customer.email, saved_order)
        
        return OrderDTO.from_entity(saved_order)
```

### 課題

**1. モックオブジェクトの設計**
- 各依存関係のモック作成
- モックの振る舞い設定

**2. 正常系テスト**
- 正常な注文作成フロー
- モックの呼び出し検証

**3. 異常系テスト**
- 存在しない顧客
- 存在しない商品
- 在庫不足
- 各種例外のハンドリング

**4. 副作用のテスト**
- 在庫引当の実行
- メール送信の実行
- データベース保存の実行

## 問題5-4: Repository層の統合テスト

以下のリポジトリ実装に対してデータベースを使った統合テストを作成してください。

```python
class SqlAlchemyOrderRepository(IOrderRepository):
    def __init__(self, session: Session):
        self.session = session
    
    def save(self, order: Order) -> Order:
        # 既存注文の更新か新規作成かを判定
        existing = self.session.query(OrderModel).filter(
            OrderModel.id == order.id
        ).first()
        
        if existing:
            # 更新処理
            existing.status = order.status.value
            existing.total_amount = order.total_amount
            
            # 既存アイテムを削除
            self.session.query(OrderItemModel).filter(
                OrderItemModel.order_id == order.id
            ).delete()
        else:
            # 新規作成
            existing = OrderModel(
                id=order.id,
                customer_id=order.customer_id,
                status=order.status.value,
                total_amount=order.total_amount,
                created_at=order.created_at
            )
            self.session.add(existing)
        
        # アイテムを追加
        for item in order.items:
            item_model = OrderItemModel(
                id=item.id,
                order_id=order.id,
                product_id=item.product_id,
                quantity=item.quantity,
                unit_price=item.unit_price
            )
            self.session.add(item_model)
        
        self.session.commit()
        return order
    
    def find_by_id(self, order_id: str) -> Optional[Order]:
        model = self.session.query(OrderModel).filter(
            OrderModel.id == order_id
        ).first()
        
        if not model:
            return None
        
        items = []
        for item_model in model.items:
            items.append(OrderItem(
                id=item_model.id,
                product_id=item_model.product_id,
                quantity=item_model.quantity,
                unit_price=item_model.unit_price
            ))
        
        return Order(
            id=model.id,
            customer_id=model.customer_id,
            items=items,
            status=OrderStatus(model.status),
            created_at=model.created_at,
            total_amount=model.total_amount
        )
```

### 課題

**1. テストデータベースの設定**
- テスト用のDBセットアップ
- テストごとのデータクリーンアップ

**2. CRUD操作のテスト**
- 新規保存のテスト
- 更新のテスト
- 検索のテスト
- 複雑な条件での検索

**3. データ整合性のテスト**
- 関連データの正確な保存
- トランザクション境界
- エラー時のロールバック

## 問題5-5: API層のEnd-to-Endテスト

FastAPIのエンドポイントに対してE2Eテストを作成してください。

```python
@router.post("/orders", response_model=OrderResponseDTO)
@inject
def create_order(
    dto: CreateOrderDTO,
    use_case: CreateOrderUseCase = Depends(Provide[Container.create_order_use_case])
) -> OrderResponseDTO:
    try:
        result = use_case.execute(dto)
        return OrderResponseDTO.from_dto(result)
    except CustomerNotFoundException as e:
        raise HTTPException(status_code=404, detail=f"顧客が見つかりません: {e.customer_id}")
    except ProductNotFoundException as e:
        raise HTTPException(status_code=404, detail=f"商品が見つかりません: {e.product_id}")
    except InsufficientStockException as e:
        raise HTTPException(status_code=409, detail=f"在庫不足: {e.product_id}")
    except Exception as e:
        raise HTTPException(status_code=500, detail="内部サーバーエラー")
```

### 課題

**1. テスト環境の構築**
- TestClientの設定
- テスト用DIコンテナ
- テストデータの準備

**2. 正常系E2Eテスト**
- 完全な注文フローのテスト
- レスポンスの検証
- データベース状態の確認

**3. 異常系E2Eテスト**
- 各種エラーケースのテスト
- 適切なHTTPステータスコード
- エラーメッセージの検証

## 問題5-6: テストダブルの適切な使い分け

以下のシナリオでどのテストダブル（Stub, Mock, Spy, Fake）を使うべきか判断してください。

### シナリオ

**1. メール送信サービスのテスト**
```python
class EmailService:
    def send_email(self, to: str, subject: str, body: str) -> bool:
        # 実際のメール送信処理
        pass
```

**2. 時刻依存の処理のテスト**
```python
class SubscriptionService:
    def __init__(self, clock: Clock):
        self.clock = clock
    
    def is_subscription_active(self, subscription: Subscription) -> bool:
        return subscription.expires_at > self.clock.now()
```

**3. 外部API呼び出しのテスト**
```python
class PaymentService:
    def __init__(self, payment_gateway: IPaymentGateway):
        self.gateway = payment_gateway
    
    def process_payment(self, amount: int, card_token: str) -> PaymentResult:
        return self.gateway.charge(amount, card_token)
```

**4. 複雑な計算ロジックのテスト**
```python
class PricingService:
    def __init__(self, discount_repo: IDiscountRepository):
        self.discount_repo = discount_repo
    
    def calculate_price(self, product_id: str, customer_id: str) -> int:
        # 複雑な価格計算ロジック
        pass
```

### 課題

各シナリオで：
1. どのテストダブルを使うべきか選択
2. 選択理由を説明
3. 具体的な実装例を提示

## 問題5-7: テストの品質指標

以下のテストコードの品質を評価し、改善案を提示してください。

```python
def test_create_order():
    # Arrange
    repo = Mock()
    product_repo = Mock()
    customer_repo = Mock()
    inventory = Mock()
    email = Mock()
    
    service = CreateOrderUseCase(repo, product_repo, customer_repo, inventory, email)
    
    # Act  
    dto = CreateOrderDTO(customer_id="123", items=[])
    result = service.execute(dto)
    
    # Assert
    assert result is not None
    repo.save.assert_called_once()

def test_order_total_calculation():
    order = Order("1", "customer1", [])
    order.add_item("product1", 2, 1000)
    order.add_item("product2", 1, 500) 
    assert order.total_amount == 2500

def test_email_sending():
    email_service = EmailService()
    result = email_service.send_email("test@example.com", "Test", "Body")
    assert result == True
```

### 課題

**1. テスト品質の問題点を指摘**
- 可読性、保守性、信頼性の観点から

**2. 改善案の提示**
- 具体的な修正版コード

**3. テスト品質の指標**
- 良いテストの条件を5つ挙げてください

---

## 解答例

### 問題5-1の解答例

**Entity層のテスト責務:**
- ビジネスルールの正確性
- データの整合性
- 不変条件の維持
- エッジケースの処理

**Use Case層のテスト責務:**
- ビジネスフローの正確性
- 依存関係の適切な呼び出し
- 例外ハンドリング
- トランザクション境界

### 問題5-2の解答例

```python
class TestOrder:
    def test_add_item_正常系(self):
        # Arrange
        order = Order("1", "customer1", [])
        
        # Act
        order.add_item("product1", 2, 1000)
        
        # Assert
        assert len(order.items) == 1
        assert order.items[0].product_id == "product1"
        assert order.items[0].quantity == 2
        assert order.total_amount == 2000
    
    def test_add_item_数量が0以下_例外発生(self):
        # Arrange
        order = Order("1", "customer1", [])
        
        # Act & Assert
        with pytest.raises(ValueError, match="数量は1以上である必要があります"):
            order.add_item("product1", 0, 1000)
```