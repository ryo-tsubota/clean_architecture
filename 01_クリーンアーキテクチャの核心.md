# 第1章: クリーンアーキテクチャの核心

クリーンアーキテクチャの具体的な実装方法に入る前に、その根底にある哲学と、全体を貫く最も重要なルールを理解する必要があります。この章では、クリーンアーキテクチャが何を目指しているのか、そしてその目的を達成するための基本原則について学びます。

## 1-1. 哲学と目的: 変更容易性、テスト容易性、独立性

クリーンアーキテクチャの哲学は、**「良いソフトウェアアーキテクチャは、システムのライフサイクルコストを最小限に抑え、プログラマの生産性を最大限に高めるものである」** という考えに基づいています。

その目的を達成するために、以下の3つの重要な特性を追求します。

1.  **変更容易性 (Maintainability)**
    ソフトウェアは常に変化します。ビジネスルールの変更、新機能の追加、仕様の修正など、変更は避けられません。良いアーキテクチャは、このような変更を容易かつ安全に行えるように設計されている必要があります。特定の変更がシステムの広範囲に影響を及ぼす（結合度が高い）のではなく、影響範囲が限定的（凝集度が高い）であることが理想です。

2.  **テスト容易性 (Testability)**
    システムの振る舞いを保証するためには、テストが不可欠です。クリーンアーキテクチャは、ビジネスロジックをUIやデータベースなどの外部要因から切り離すことで、テストを容易にします。外部への依存がないコードは、セットアップも不要で、高速に実行できるユニットテストが可能です。

3.  **独立性 (Independence)**
    ビジネスロジックは、特定のフレームワーク、UI、データベース、あるいは外部のエージェントから独立しているべきです。これにより、技術選定の自由度が高まり、将来的な技術の移行やアップグレードが容易になります。例えば、「Webアプリケーションをコンソールアプリケーションに変更する」といった大きな変更も、ビジネスロジックに手を加えることなく実現できるのが理想です。

これらの目的は、ソフトウェアを「柔らかく（soft）」保つこと、つまり、変更に対して柔軟であることを目指しています。

## 1-2. 重要な原則: 関心の分離 (Separation of Concerns - SoC)

上記の目的を達成するための基本的な戦略が**「関心の分離 (SoC)」**です。

これは、ソフトウェアを異なる責務を持つ複数の部分に分割するという、古くからある設計原則です。クリーンアーキテクチャは、この原則をアーキテクチャレベルで徹底的に適用します。

具体的には、ソフトウェアを以下のような関心事に基づいて分割します。

*   **ビジネス全体のルール (Enterprise-wide business rules)**: 会社の収益やコストに直接関わるような、最も重要で普遍的なロジック。
*   **アプリケーション固有のルール (Application-specific business rules)**: 特定のアプリケーションの機能を実現するためのロジック。
*   **ユーザーインターフェース (UI)**: ユーザーとの対話を受け持つ部分。
*   **データベース (Database)**: データの永続化を受け持つ部分。

これらを混ぜこぜにせず、それぞれを独立したコンポーネントとして開発することで、関心の分離を実現します。

## 1-3. 依存性のルール (The Dependency Rule)

クリーンアーキテクチャにおける**唯一かつ絶対のルール**が、この「依存性のルール」です。

> **ソースコードの依存関係は、必ず内側（高レベルの方針）に向かわなければならない。外側（低レベルの詳細）にあるものは、内側にあるものを知ってはならない。**

このルールを理解するために、次の同心円モデルを見てみましょう。

## 1-4. 同心円モデルの概観

クリーンアーキテクチャは、よく同心円の図で表現されます。この円は、ソフトウェアの異なるレイヤー（関心事）を表しています。

```
        -----------------------------------------------------
       /                                                     \
      /      Frameworks & Drivers (フレームワーク & ドライバ)     \
     /                (Web, DB, UI, etc.)                    \
    |    -------------------------------------------------    |
    |   /                                                 \   |
    |  /         Interface Adapters (I/Fアダプタ)           \  |
    | /              (Controllers, Presenters, Gateways)      \ |
    | |      -----------------------------------------      | |
    | |     /                                         \     | |
    | |    /            Use Cases (ユースケース)         \    | |
    | |   /         (Application Business Rules)          \   | |
    | |  |          ---------------------------          |  | |
    | |  |         /                         \         |  | |
    | |  |        /         Entities          \        |  | |
    | |  |        \       (Enterprise)        /        |  | |
    | |  |          \-------------------------/         |  | |
    | |   \                                           /   | |
    | |    \                                         /    | |
    | |     \-----------------------------------------/     | |
    |  \                                                 /  |
    |   \-------------------------------------------------/   |
     \                                                     /
      \-----------------------------------------------------/

```

*   **内側に行くほど、抽象度が高く、高レベルな方針**を扱います。
*   **外側に行くほど、具体的で、低レベルな詳細**を扱います。

各レイヤーの役割は以下の通りです。

*   **Entities (エンティティ)**: 最も内側のレイヤー。システム全体で共通の、最も重要なビジネスルールをカプセル化します。このレイヤーのコードは、アプリケーションがどう動くかについては何も知りません。

*   **Use Cases (ユースケース)**: アプリケーション固有のビジネスルールを実装します。エンティティを操作して、特定のユースケース（例：「ユーザーを登録する」「商品を注文する」）を実現します。このレイヤーは、UIやデータベースがどうなっているかを知りません。

*   **Interface Adapters (インターフェースアダプター)**: ユースケース層やエンティティ層にとって都合の良い形式と、外部のフレームワークやツールにとって都合の良い形式とを相互に変換する責務を持ちます。コントローラー、プレゼンター、ゲートウェイ（リポジトリ）などがこの層に属します。

*   **Frameworks & Drivers (フレームワーク & ドライバ)**: 最も外側のレイヤー。Webフレームワーク、データベース、UIフレームワークなど、具体的な技術詳細がここに配置されます。このレイヤーは、いわば「接着剤」の役割を果たします。

**依存性のルール**は、この図で言えば、**矢印が常に内側を向いている**ことを意味します。

例えば、**Use Cases**レイヤーは**Entities**レイヤーに依存しますが、その逆はありません。同様に、**Interface Adapters**レイヤーは**Use Cases**レイヤーに依存します。

このルールを徹底することで、ビジネスロジック（内側の円）は、フレームワークやデータベース（外側の円）の変更から完全に保護されるのです。これが、クリーンアーキテクチャが目指すシステムの姿。
