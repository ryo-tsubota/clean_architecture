# 第2章: レイヤーの深掘り

前の章では、クリーンアーキテクチャの全体像と同心円モデル、そして最も重要な「依存性のルール」について学びました。この章では、それぞれのレイヤーが具体的にどのような責務を持ち、Pythonでどのように表現されるのかを詳しく見ていきましょう。

## 2-1. Entities: ビジネスの核となるデータとルール

**責務:**
エンティティは、クリーンアーキテクチャの最内円に位置し、**システム全体で共通の、最も本質的なビジネスルール**をカプセル化します。これらは、アプリケーションの振る舞いが変わっても、変更されることのない、高レベルな概念です。

*   エンティティは、特定のデータベースやフレームワークに依存しない、純粋なビジネスオブジェクトです。
*   データ構造だけでなく、そのデータを操作するための不変のビジネスロジック（メソッド）を持ちます。

**Pythonでの表現方法:**

Pythonでは、エンティティを表現するために `dataclasses` や `Pydantic` のようなライブラリを使うのが一般的です。これらは、型安全で不変（immutable）なデータオブジェクトを簡単に作成するのに役立ちます。

**例: ECサイトの `Product` エンティティ**

```python
from dataclasses import dataclass
from decimal import Decimal

@dataclass(frozen=True)
class Product:
    id: str
    name: str
    price: Decimal
    description: str

    def is_expensive(self) -> bool:
        """この商品が高価かどうかを判断するビジネスルール"""
        return self.price > Decimal("10000")

    def change_price(self, new_price: Decimal) -> 'Product':
        """価格を変更するビジネスロジック。新しいインスタンスを返す"""
        if new_price <= 0:
            raise ValueError("価格は正の値でなければなりません")
        return Product(id=self.id, name=self.name, price=new_price, description=self.description)
```

この `Product` クラスは、特定のライブラリに依存せず、それ自体で完結しています。`is_expensive` のようなメソッドが、データに紐づくビジネスルールです。

## 2-2. Use Cases: アプリケーション固有のビジネスロジック

**責務:**
ユースケースレイヤーは、エンティティを操作して、**特定のアプリケーションの目的を達成するためのビジネスロジック**を実装します。このレイヤーのクラスは、しばしば **Interactor（インタラクター）** と呼ばれます。

*   「ユーザーを登録する」「商品をカートに追加する」といった、具体的な操作フローを制御します。
*   UIやデータベースが何であるかを知りませんが、それらと対話するための「窓口（ポート）」を定義します。

**Interactor, Input Port, Output Port:**

*   **Interactor**: ユースケースのロジックそのもの。
*   **Input Port**: Interactorが公開するインターフェース（窓口）。外側のレイヤー（Controllerなど）は、このポートを通じてユースケースを実行します。
*   **Output Port**: Interactorが結果を返すためのインターフェース。外側のレイヤー（Presenterなど）は、このポートを実装して結果を受け取ります。

このポートの概念により、ユースケースは外側の世界から完全に独立します。

**例: 商品を作成するユースケース**

```python
# --- ユースケース層 --- 
from abc import ABC, abstractmethod

# Input Data (入力データ構造)
@dataclass
class CreateProductInput:
    name: str
    price: float

# Output Data (出力データ構造)
@dataclass
class CreateProductOutput:
    id: str
    name: str

# Output Port (出力ポートのインターフェース)
class ICreateProductOutputPort(ABC):
    @abstractmethod
    def present(self, output: CreateProductOutput):
        pass

# Repository Port (DB操作のインターフェース)
class IProductRepository(ABC):
    @abstractmethod
    def save(self, product: Product) -> None:
        pass

# Interactor (ユースケース本体)
class CreateProductInteractor:
    def __init__(self, repository: IProductRepository, presenter: ICreateProductOutputPort):
        self.repository = repository
        self.presenter = presenter

    def execute(self, input_data: CreateProductInput) -> None:
        # エンティティを作成
        product = Product(id=generate_id(), name=input_data.name, price=Decimal(input_data.price), ...)
        
        # リポジトリを使って永続化
        self.repository.save(product)
        
        # 出力データを作成してプレゼンターに渡す
        output_data = CreateProductOutput(id=product.id, name=product.name)
        self.presenter.present(output_data)
```

このコードでは、`CreateProductInteractor` は `IProductRepository` というインターフェースにのみ依存しており、具体的なデータベースの実装を知りません。これが「依存性のルール」の実践です。

## 2-3. Interface Adapters: 変換者たちの役割

**責務:**
このレイヤーは、ユースケース層やエンティティ層にとって都合の良いデータ形式と、フレームワークやドライバ層（UI, DBなど）にとって都合の良いデータ形式とを、**相互に変換する**責務を負います。

**主な登場人物:**

*   **Controllers (コントローラー)**: UIやWebからの入力を受け取り、ユースケースの入力データ形式に変換して、ユースケース（Interactor）を実行します。
*   **Presenters (プレゼンター)**: ユースケースからの出力データを受け取り、UIやWebが表示しやすい形式（ViewModelやJSONなど）に変換します。
*   **Gateways / Repositories (ゲートウェイ / リポジトリ)**: ユースケース層が定義したインターフェース（例: `IProductRepository`）を実装します。エンティティオブジェクトを、データベースのORMモデルやSQLクエリに変換し、永続化の処理を実行します。

**例: FastAPIを使ったControllerと、SQLAlchemyを使ったRepositoryの実装**

```python
# --- インターフェースアダプター層 ---

# Controller (FastAPIのエンドポイント)
@router.post("/products")
def create_product_endpoint(input_data: CreateProductInput, ...):
    # UseCaseを実行
    interactor.execute(input_data)
    # Presenterが結果を返す (詳細は後述)
    return ...

# Repository (SQLAlchemyによる実装)
class ProductRepository(IProductRepository):
    def __init__(self, db_session):
        self.session = db_session

    def save(self, product: Product) -> None:
        # EntityからORMモデルへ変換
        orm_product = ProductModel(id=product.id, name=product.name, ...)
        self.session.add(orm_product)
        self.session.commit()
```

## 2-4. Frameworks & Drivers: 最も外側の世界

**責務:**
このレイヤーは、**すべての具体的な技術詳細**が含まれる場所です。いわば「接着剤」であり、他のレイヤーは、このレイヤーの存在を一切知りません。

**含まれるもの:**

*   **Webフレームワーク**: FastAPI, Flask, Djangoなど
*   **データベース**: PostgreSQL, MySQL, SQLiteなど
*   **ORM**: SQLAlchemy, Django ORMなど
*   **UIフレームワーク**: React, Vue (Webフロントエンド), PyQt (デスクトップ)など
*   **DIコンテナ**: `dependency-injector`など
*   アプリケーションを起動するためのメインのスクリプト (`main.py`)

このレイヤーの役割は、これまでのレイヤーで定義されてきたインターフェースの実装を提供し、それらを組み合わせてアプリケーション全体を起動することです。

この厳格なレイヤー分離と依存性のルールこそが、クリーンアーキテクチャの真髄です。次の章では、これらのレイヤーをPythonプロジェクトとして、どのように構成し、依存関係を解決していくのかを学びます。
