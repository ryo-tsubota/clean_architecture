# 第6章: 発展トピックとベストプラクティス

これまでの章で、クリーンアーキテクチャの基本から実践的なテストまでを学びました。この最後の章では、実際のプロジェクトで考慮すべきいくつかの発展的なトピックと、このアーキテクチャを採用する上での心構えについて解説します。

## 6-1. エラーハンドリング戦略

堅牢なアプリケーションを構築するには、適切なエラーハンドリングが不可欠です。クリーンアーキテクチャでは、エラーもレイヤーの責務に応じて処理します。

**基本方針:**
*   **ユースケース層は、ビジネス的な例外を定義して送出する。**
*   **インターフェースアダプター層（特にController）は、そのビジネス例外を捕捉し、外部の世界（例: HTTPクライアント）に適した形式に変換する。**

**1. ビジネス例外の定義**

ユースケース層やドメイン層で、アプリケーション固有の例外クラスを定義します。

```python
# src/application/exceptions.py (新規作成)

class ApplicationException(Exception):
    """アプリケーション例外の基底クラス"""
    pass

class TodoNotFoundException(ApplicationException):
    """指定されたToDoが見つからない場合の例外"""
    def __init__(self, todo_id: str):
        self.todo_id = todo_id
        super().__init__(f"Todo with id '{todo_id}' not found.")

class InvalidTodoStateException(ApplicationException):
    """不正な状態遷移（例: 完了済みのタスクを再度完了させる）"""
    pass
```

**2. ユースケースでの例外送出**

ユースケースは、`ValueError` のような汎用的な例外の代わりに、上で定義したビジネス例外を使います。

```python
# src/application/use_cases.py の一部を修正

from .exceptions import TodoNotFoundException, InvalidTodoStateException

class TodoUseCases:
    # ...
    def complete_todo(self, todo_id: str) -> TodoDTO:
        todo = self.repo.find_by_id(todo_id)
        if not todo:
            raise TodoNotFoundException(todo_id)
        
        try:
            completed_todo_entity = todo.mark_as_completed()
        except ValueError as e:
            # ドメイン層の汎用例外をビジネス例外に変換
            raise InvalidTodoStateException(str(e))

        updated_todo = self.repo.save(completed_todo_entity)
        return TodoDTO.from_orm(updated_todo)
```

**3. FastAPIでの一元的な例外ハンドリング**

コントローラーで `try-except` を書く代わりに、FastAPIの例外ハンドラ機能を使って、ビジネス例外をHTTPエラーレスポンスに一元的に変換します。これは `main.py` で設定するのが良いでしょう。

```python
# src/main.py に追記

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from src.application.exceptions import TodoNotFoundException, InvalidTodoStateException

# ... create_app の中で ...
app = FastAPI()

@app.exception_handler(TodoNotFoundException)
async def todo_not_found_exception_handler(request: Request, exc: TodoNotFoundException):
    return JSONResponse(
        status_code=404,
        content={"message": str(exc)}
    )

@app.exception_handler(InvalidTodoStateException)
async def invalid_state_exception_handler(request: Request, exc: InvalidTodoStateException):
    return JSONResponse(
        status_code=400, # Bad Request
        content={"message": str(exc)}
    )

# ...
```

これにより、コントローラーのコードは成功系の処理に集中でき、クリーンな状態を保てます。

## 6-2. 設定情報の管理

データベースの接続URLや外部APIのキーといった設定情報は、環境によって変わる「詳細」です。これらがコードにハードコーディングされるべきではありません。

第4章で実践したように、DIコンテナ（`dependency-injector`）の `providers.Configuration` を使うのが非常に有効です。

`src/container.py` の例:
```python
class Container(containers.DeclarativeContainer):
    config = providers.Configuration()
    # 環境変数 `DATABASE_URL` から読み込む。なければデフォルト値を使用。
    config.db_url.from_env("DATABASE_URL", "sqlite:///./default.db")
    # YAMLやINIファイルから読み込むことも可能
    # config.from_yaml('config.yml')

    engine = providers.Singleton(create_engine, url=config.db_url)
    # ...
```

このアプローチの利点:
*   設定の出所（環境変数、ファイルなど）を一箇所で管理できる。
*   設定値を必要とするコンポーネントに、DIコンテナを通じて注入できる。
*   テスト時には、テスト用の設定値を簡単に上書きできる。

## 6-3. クリーンアーキテクチャの採用におけるトレードオフ

クリーンアーキテクチャは多くの利点をもたらしますが、銀の弾丸ではありません。採用にあたっては、そのトレードオフを理解しておくことが重要です。

**利点（再確認）**
*   **メンテナンス性**: 変更の影響範囲が限定され、長期的な保守が容易になる。
*   **テスト容易性**: ビジネスロジックを高速かつ安定してテストできる。
*   **技術的独立性**: フレームワークやDBの変更・移行が容易になる。

**考慮すべきトレードオフ**

*   **初期コストと複雑性の増加**
    *   **ボイラープレートコードの増加**: レイヤー間のインターフェース（ABC）、DTO、DIコンテナの設定など、記述すべき「お決まりのコード」は確実に増えます。
    *   **過剰設計のリスク**: 小規模な使い捨てのスクリプトや、非常にシンプルなCRUDしかないアプリケーションに対しては、明らかに過剰設計です。アーキテクチャを維持するためのコストが、得られるメリットを上回る可能性があります。

*   **学習コスト**
    *   チーム開発の場合、メンバー全員がクリーンアーキテクチャの原則（特に依存性のルール）を理解し、遵守する必要があります。
    *   新しいメンバーがプロジェクトに参加する際の学習コストは、フレームワークの作法だけを覚えればよいプロジェクトに比べて高くなる可能性があります。

**どのような場合に採用を検討すべきか？**

クリーンアーキテクチャが真価を発揮するのは、以下のような特徴を持つプロジェクトです。

*   **長期間（数年以上）にわたって開発・保守されることが想定される。**
*   **複雑なビジネスロジックを持つ、または将来的に持つことが予想される。**
*   **開発チームの規模が中〜大規模である。**
*   **技術選定（特にフレームワークやDB）が将来変更になる可能性がある。**

逆に、短期的なプロトタイプや、内部向けの簡単なツールなどでは、よりシンプルなアプローチ（例えば、FastAPIの標準的な作法に則るなど）の方が費用対効果が高いでしょう。

アーキテクチャは目的を達成するための手段です。プロジェクトの特性を見極め、適切な道具を選択するエンジニアリングの判断が重要となります。
